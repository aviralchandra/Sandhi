<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.6.1">
  <compounddef id="page_msg_passing" kind="page">
    <compoundname>page_msg_passing</compoundname>
    <title>Message Passing</title>
    <detaileddescription>
<sect1 id="page_affinity_1intro">
<title>Introduction</title>
<para>GNU Radio was originally a streaming system with no other mechanism to pass data between blocks. Streams of data are a model that work well for samples, bits, etc., but are not really the right mechanism for control data, metadata, and, often, packet structures (at least at some point in the processing chain).</para><para>We solved part of this problem a few years ago by introducing the tag stream. This is a parallel stream to the data streaming. The difference is that tags are designed to hold metadata and control information. Tags are specifically associated with a particular sample in the data stream and flow downstream alongside the data. This model allows other blocks to identify that an event or action has occurred or should occur on a particular item. The major limitation is that the tag stream is really only accessible inside a work function and only flows in one direction. Its benefit is that it is isosynchronous with the data.</para><para>We want a more general message passing system for a couple of reasons. The first is to allow blocks downstream to communicate back to blocks upstream. The second is to allow an easier way for us to communicate back and forth between external applications and GNU Radio. The new message passing interface handles these cases, although it does so on an asynchronous basis.</para><para>The message passing interface heavily relies on Polymorphic Types (PMTs) in GNU Radio. For further information about these data structures, see the page <ref refid="page_pmt" kindref="compound">Polymorphic Types</ref>.</para></sect1>
<sect1 id="page_msg_passing_1api">
<title>Message Passing API</title>
<para>The message passing interface is designed into the <ref refid="classgr__basic__block" kindref="compound">gr_basic_block</ref>, which is the parent class for all blocks in GNU Radio. Each block has a set of message queues to hold incoming messages and can post messages to the message queues of other blocks. The blocks also distinguish between input and output ports.</para><para>A block has to declare its input and output message ports in its constructor. The message ports are described by a name, which is in practice a PMT symbol (<emphasis>i.e.</emphasis>, an interned string). The API calls to register a new port are:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>message_port_register_in(<ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>port_id)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>message_port_register_out(<ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>port_id)</highlight></codeline>
</programlisting></para><para>The ports are now identifiable by that port name. Other blocks who may want to post or receive messages on a port must subscribe to it. When a block has a message to send, they are published on a particular port. The subscribe and publish API looks like:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>message_port_pub(<ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>port_id,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>msg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>message_port_sub(<ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>port_id,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>target);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>message_port_unsub(<ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>port_id,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>target);</highlight></codeline>
</programlisting></para><para>Any block that has a subscription to another block&apos;s output message port will receive the message when it is published. Internally, when a block publishes a message, it simply iterates through all blocks that have subscribed and uses the <ref refid="classgr__basic__block_1abc3f1986711d1d7f429bff7df1de7de4" kindref="member">gr_basic_block::_post</ref> method to send the message to that block&apos;s message queue.</para><para>From the flowgraph level, we have instrumented a gr_hier_block2::msg_connect method to make it easy to subscribe blocks to other blocks&apos; messages. The message connection method looks like the following code. Assume that the block <bold>src</bold> has an output message port named <emphasis>pdus</emphasis> and the block <bold>dbg</bold> has an input port named <emphasis>print</emphasis>.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">self</highlight><highlight class="normal">.tb.msg_connect(src,<sp/></highlight><highlight class="stringliteral">&quot;pdus&quot;</highlight><highlight class="normal">,<sp/>dbg,<sp/></highlight><highlight class="stringliteral">&quot;print&quot;</highlight><highlight class="normal">)</highlight></codeline>
</programlisting></para><para>All messages published by the <bold>src</bold> block on port <emphasis>pdus</emphasis> will be received by <bold>dbg</bold> on port <emphasis>print</emphasis>. Note here how we are just using strings to define the ports, not PMT symbols. This is a convenience to the user to be able to more easily type in the port names (for reference, you can create a PMT symbol in Python using the <ref refid="namespacepmt_1a57a5ae8877c9b3b24636a07e0a3596e1" kindref="member">pmt::pmt_intern</ref> function as <ref refid="namespacepmt_1a57a5ae8877c9b3b24636a07e0a3596e1" kindref="member">pmt.pmt_intern</ref>(&quot;string&quot;)).</para><para>Users can also query blocks for the names of their input and output ports using the following API calls:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>message_ports_in();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>message_ports_out();</highlight></codeline>
</programlisting></para><para>The return value for these are a PMT vector filled with PMT symbols, so PMT operators must be used to manipulate them.</para><para>Each block has internal methods to handle posting and receiving of messages. The <ref refid="classgr__basic__block_1abc3f1986711d1d7f429bff7df1de7de4" kindref="member">gr_basic_block::_post</ref> method takes in a message and places it into its queue. The publishing model uses the <ref refid="classgr__basic__block_1abc3f1986711d1d7f429bff7df1de7de4" kindref="member">gr_basic_block::_post</ref> method of the blocks as the way to access the message queue. So the message queue of the right name will have a new message. Posting messages also has the benefit of waking up the block&apos;s thread if it is in a wait state. So if idle, as soon as a message is posted, it will wake up and and call the message handler.</para><para>The other side of the action in a block is in the message handler. When a block has an input message port, it needs a callback function to handle messages received on that port. We use a Boost bind operator to bind the message port to the message handling function. When a new message is pushed onto a port&apos;s message queue, it is this function that is used to process the message.</para></sect1>
<sect1 id="page_msg_passing_1examples">
<title>Code Examples</title>
<para>The following is snippets of code from blocks current in GNU Radio that take advantage of message passing. We will be using gr_message_debug and <ref refid="classgr__tagged__stream__to__pdu" kindref="compound">gr_tagged_stream_to_pdu</ref> below to show setting up both input and output message passing capabilities.</para><para>The gr_message_debug block is used for debugging the message passing system. It describes two input message ports: <emphasis>print</emphasis> and <emphasis>store</emphasis>. The <emphasis>print</emphasis> port simply prints out all messages to standard out while the <emphasis>store</emphasis> port keeps a list of all messages posted to it. This latter port works in conjunction with a gr_message_debug::get_message(int i) call that allows us to retrieve message <computeroutput>i</computeroutput> afterward.</para><para>The constructor of this block looks like this:</para><para><programlisting><codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>message_port_register_in(<ref refid="namespacepmt_1a90faad6086ac00280e0cfd8bb541bd64" kindref="member" tooltip="Make pmt symbol.">pmt::mp</ref>(</highlight><highlight class="stringliteral">&quot;print&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>set_msg_handler(<ref refid="namespacepmt_1a90faad6086ac00280e0cfd8bb541bd64" kindref="member" tooltip="Make pmt symbol.">pmt::mp</ref>(</highlight><highlight class="stringliteral">&quot;print&quot;</highlight><highlight class="normal">),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::bind(&amp;gr_message_debug::print,<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>_1));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>message_port_register_in(<ref refid="namespacepmt_1a90faad6086ac00280e0cfd8bb541bd64" kindref="member" tooltip="Make pmt symbol.">pmt::mp</ref>(</highlight><highlight class="stringliteral">&quot;store&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>set_msg_handler(<ref refid="namespacepmt_1a90faad6086ac00280e0cfd8bb541bd64" kindref="member" tooltip="Make pmt symbol.">pmt::mp</ref>(</highlight><highlight class="stringliteral">&quot;store&quot;</highlight><highlight class="normal">),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>boost::bind(&amp;gr_message_debug::store,<sp/></highlight><highlight class="keyword">this</highlight><highlight class="normal">,<sp/>_1));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>So the two ports are registered by their respective names. We then use the <ref refid="classgr__basic__block_1af1a987df65146b6e58c64bd4ada2dc06" kindref="member">gr_basic_block::set_msg_handler</ref> function to identify this particular port name with a callback function. The Boost <emphasis>bind</emphasis> function (<ulink url="http://www.boost.org/doc/libs/1_52_0/libs/bind/bind.html">Boost::bind</ulink>) here binds the callback to a function of this block&apos;s class. So now the block&apos;s gr_message_debug::print and gr_message_debug::store functions are assigned to handle messages passed to them. Below is the <emphasis>print</emphasis> function for reference.</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">gr_message_debug::print(<ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>msg)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;*****<sp/>MESSAGE<sp/>DEBUG<sp/>PRINT<sp/>********\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacepmt_1aef241cfd8cabf5a7e363d7041ccbe1bb" kindref="member" tooltip="Write pmt string representation to stdout.">pmt::pmt_print</ref>(msg);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;**********************************\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>The function simply takes in the PMT message and prints it. The method <ref refid="namespacepmt_1aef241cfd8cabf5a7e363d7041ccbe1bb" kindref="member">pmt::pmt_print</ref> is a function in the PMT library to print the PMT in a friendly, (mostly) pretty manner.</para><para>The <ref refid="classgr__tagged__stream__to__pdu" kindref="compound">gr_tagged_stream_to_pdu</ref> block only defines a single output message port. In this case, its constructor looks like:</para><para><programlisting><codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>message_port_register_out(<ref refid="gr__pdu_8h_1a5663ead78c7815f69f7324dee8b61c5d" kindref="member">pdu_port_id</ref>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>So we are only creating a single output port where <emphasis>pdu_port_id</emphasis> is defined in the file <ref refid="gr__pdu_8h" kindref="compound">gr_pdu.h</ref> as <emphasis>pdus</emphasis>.</para><para>This blocks purpose is to take in a stream of samples along with stream tags and construct a predefined PDU message from this. In GNU Radio, we define a PDU as a PMT pair of (metadata, data). The metadata describes the samples found in the data portion of the pair. Specifically, the metadata can contain the length of the data segment and any other information (sample rate, etc.). The PMT vectors know their own length, so the length value is not actually necessary unless useful for purposes down the line. The metadata is a PMT dictionary while the data segment is a PMT uniform vector of either bytes, floats, or complex values.</para><para>In the end, when a PDU message is ready, the block calls its <ref refid="classgr__tagged__stream__to__pdu_1a43dcf77f17f40de216435d84563f3565" kindref="member">gr_tagged_stream_to_pdu::send_message</ref> function that is shown below.</para><para><programlisting><codeline><highlight class="keywordtype">void</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">gr_tagged_stream_to_pdu::send_meassage()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<ref refid="namespacepmt_1a76684f2c30f1f0134f526dababa3aa89" kindref="member" tooltip="Return the number of elements in v.">pmt::pmt_length</ref>(d_pdu_vector)<sp/>!=<sp/>d_pdu_length)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(</highlight><highlight class="stringliteral">&quot;msg<sp/>length<sp/>not<sp/>correct&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacepmt_1ab4b70d9293452eb74dd07c670e6811fa" kindref="member" tooltip="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</ref><sp/>msg<sp/>=<sp/><ref refid="namespacepmt_1af049aaa257cc52e35a2ef8ed6a75b45b" kindref="member" tooltip="Return a newly allocated pair whose car is x and whose cdr is y.">pmt::pmt_cons</ref>(d_pdu_meta,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>d_pdu_vector);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="structgr__block_1a798896705e664b90c16992e7ad6a5c18" kindref="member">message_port_pub</ref>(<ref refid="gr__pdu_8h_1a5663ead78c7815f69f7324dee8b61c5d" kindref="member">pdu_port_id</ref>,<sp/>msg);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>d_pdu_meta<sp/>=<sp/><ref refid="namespacepmt_1abacba9cd6ea4261fee4bfb67e7133dad" kindref="member">pmt::PMT_NIL</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>d_pdu_vector<sp/>=<sp/><ref refid="namespacepmt_1abacba9cd6ea4261fee4bfb67e7133dad" kindref="member">pmt::PMT_NIL</ref>;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>d_pdu_length<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>d_pdu_remain<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>d_inpdu<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>This function does a bit of checking to make sure the PDU is ok as well as some cleanup in the end. But it is the line where the message is published that is important to this discussion. Here, the block posts the PDU message to any subscribers by calling <ref refid="classgr__basic__block_1ad2e662133322e1ba4aa68ca004a2acb0" kindref="member">gr_basic_block::message_port_pub</ref> publishing method.</para><para>There is similarly a <ref refid="classgr__pdu__to__tagged__stream" kindref="compound">gr_pdu_to_tagged_stream</ref> block that essentially does the opposite. It acts as a source to a flowgraph and waits for PDU messages to be posted to it on its input port <emphasis>pdus</emphasis>. It extracts the metadata and data and processes them. The metadata dictionary is split up into key:value pairs and stream tags are created out of them. The data is then converted into an output stream of items and passed along. The next section describes how PDUs can be passed into a flowgraph using the <ref refid="classgr__pdu__to__tagged__stream" kindref="compound">gr_pdu_to_tagged_stream</ref> block.</para></sect1>
<sect1 id="page_msg_passing_1posting">
<title>Posting from External Sources</title>
<para>The last feature of the message passing architecture to discuss here is how it can be used to take in messages from an external source. We can call a block&apos;s <ref refid="classgr__basic__block_1abc3f1986711d1d7f429bff7df1de7de4" kindref="member">gr_basic_block::_post</ref> method directly and pass it a message. So any block with an input message port can receive messages from the outside in this way.</para><para>The following example uses a <ref refid="classgr__pdu__to__tagged__stream" kindref="compound">gr_pdu_to_tagged_stream</ref> block as the source block to a flowgraph. Its purpose is to wait for messages as PDUs posted to it and convert them to a normal stream. The payload will be sent on as a normal stream while the meta data will be decoded into tags and sent on the tagged stream.</para><para>So if we have created a <bold>src</bold> block as a PDU to stream, it has a <emphasis>pdus</emphasis> input port, which is how we will inject PDU messages to the flowgraph. These PDUs could come from another block or flowgraph, but here, we will create and insert them by hand.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/>port<sp/>=<sp/>pmt.pmt_intern(</highlight><highlight class="stringliteral">&quot;pdus&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>msg<sp/>=<sp/>pmt.pmt_cons(pmt.PMT_NIL,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pmt.pmt_make_u8vector(16,<sp/>0xFF))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>src.to_basic_block()._post(port,<sp/>msg)</highlight></codeline>
</programlisting></para><para>The PDU&apos;s metadata section is empty, hence the <ref refid="namespacepmt_1abacba9cd6ea4261fee4bfb67e7133dad" kindref="member">pmt::PMT_NIL</ref> object. The payload is now just a simple vector of 16 bytes of all 1&apos;s. To post the message, we have to access the block&apos;s <ref refid="classgr__basic__block" kindref="compound">gr_basic_block</ref> class, which we do using the <ref refid="classgr__basic__block_1a87b0e931b388d349dacd6a5010b5739c" kindref="member">gr_basic_block::to_basic_block</ref> method and then call the <ref refid="classgr__basic__block_1abc3f1986711d1d7f429bff7df1de7de4" kindref="member">gr_basic_block::_post</ref> method to pass the PDU to the right port.</para><para>All of these mechanisms are explored and tested in the QA code of the file qa_pdu.py.</para><para>There are some examples of using the message passing infrastructure through GRC in gnuradio-core/src/examples/msg_passing. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
