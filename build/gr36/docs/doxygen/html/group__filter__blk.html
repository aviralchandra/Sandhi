<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GNU Radio 3.6.4.2 C++ API: Filters</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio 3.6.4.2 C++ API
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__filter__blk.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Filters</div>  </div>
<div class="ingroups"><a class="el" href="group__block.html">GNU Radio C++ Signal Processing Blocks</a></div></div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__adaptive__fir__ccc.html">gr_adaptive_fir_ccc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive FIR filter with gr_complex input, gr_complex output and float taps.  <a href="classgr__adaptive__fir__ccc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__adaptive__fir__ccf.html">gr_adaptive_fir_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive FIR filter with gr_complex input, gr_complex output and float taps.  <a href="classgr__adaptive__fir__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__fft__filter__ccc.html">gr_fft_filter_ccc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast FFT filter with gr_complex input, gr_complex output and gr_complex taps.  <a href="classgr__fft__filter__ccc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__fft__filter__fff.html">gr_fft_filter_fff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast FFT filter with float input, float output and float taps.  <a href="classgr__fft__filter__fff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__filter__delay__fc.html">gr_filter_delay_fc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter-Delay Combination Block.The block takes one or two float stream and outputs a complex stream. If only one float stream is input, the real output is a delayed version of this input and the imaginary output is the filtered output. If two floats are connected to the input, then the real output is the delayed version of the first input, and the imaginary output is the filtered output. The delay in the real path accounts for the group delay introduced by the filter in the imaginary path. The filter taps needs to be calculated before initializing this block.  <a href="classgr__filter__delay__fc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__fir__fcc__sse.html">gr_fir_fcc_sse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">SSE version of gr_fir_fcc.  <a href="classgr__fir__fcc__sse.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__fractional__interpolator__cc.html">gr_fractional_interpolator_cc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolating mmse filter with gr_complex input, gr_complex output.  <a href="classgr__fractional__interpolator__cc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__fractional__interpolator__ff.html">gr_fractional_interpolator_ff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolating mmse filter with float input, float output.  <a href="classgr__fractional__interpolator__ff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__hilbert__fc.html">gr_hilbert_fc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hilbert transformer.real output is input appropriately delayed. imaginary output is hilbert filtered (90 degree phase shift) version of input.  <a href="classgr__hilbert__fc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__iir__filter__ffd.html">gr_iir_filter_ffd</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IIR filter with float input, float output and double tapsThis filter uses the Direct Form I implementation, where <code>fftaps</code> contains the feed-forward taps, and <code>fbtaps</code> the feedback ones.  <a href="classgr__iir__filter__ffd.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__single__pole__iir__filter__cc.html">gr_single_pole_iir_filter_cc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">single pole IIR filter with complex input, complex outputThe input and output satisfy a difference equation of the form  
 \f{
 y[n] - (1-alpha) y[n-1] = alpha x[n]
 \f}
   <a href="classgr__single__pole__iir__filter__cc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__single__pole__iir__filter__ff.html">gr_single_pole_iir_filter_ff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">single pole IIR filter with float input, float outputThe input and output satisfy a difference equation of the form  
 \f{
 y[n] - (1-alpha) y[n-1] = alpha x[n]
 \f}
   <a href="classgr__single__pole__iir__filter__ff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgri__fft__filter__ccc__generic.html">gri_fft_filter_ccc_generic</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast FFT filter with gr_complex input, gr_complex output and gr_complex taps.  <a href="classgri__fft__filter__ccc__generic.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgri__fft__filter__ccc__sse.html">gri_fft_filter_ccc_sse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast FFT filter with gr_complex input, gr_complex output and gr_complex taps.  <a href="classgri__fft__filter__ccc__sse.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1adaptive__fir__ccc.html">gr::filter::adaptive_fir_ccc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive FIR filter with gr_complex input, gr_complex output and gr_complex tapsThis is a base class to implement an adaptive FIR filter. Generally, another block will inherit from this one to build a new type of adaptive filter such as an equalizer.  <a href="classgr_1_1filter_1_1adaptive__fir__ccc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1adaptive__fir__ccf.html">gr::filter::adaptive_fir_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptive FIR filter with gr_complex input, gr_complex output and float tapsThis is a base class to implement an adaptive FIR filter. Generally, another block will inherit from this one to build a new type of adaptive filter such as an equalizer.  <a href="classgr_1_1filter_1_1adaptive__fir__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1kernel_1_1fft__filter__fff.html">gr::filter::kernel::fft_filter_fff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast FFT filter with float input, float output and float taps.  <a href="classgr_1_1filter_1_1kernel_1_1fft__filter__fff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1kernel_1_1fft__filter__ccc.html">gr::filter::kernel::fft_filter_ccc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast FFT filter with gr_complex input, gr_complex output and gr_complex taps.  <a href="classgr_1_1filter_1_1kernel_1_1fft__filter__ccc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1fractional__interpolator__cc.html">gr::filter::fractional_interpolator_cc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolating MMSE filter with complex input, complex output.  <a href="classgr_1_1filter_1_1fractional__interpolator__cc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1fractional__interpolator__ff.html">gr::filter::fractional_interpolator_ff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolating MMSE filter with float input, float output.  <a href="classgr_1_1filter_1_1fractional__interpolator__ff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1iir__filter__ffd.html">gr::filter::iir_filter_ffd</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IIR filter with float input, float output and double tapsThis filter uses the Direct Form I implementation, where <code>fftaps</code> contains the feed-forward taps, and <code>fbtaps</code> the feedback ones.  <a href="classgr_1_1filter_1_1iir__filter__ffd.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1single__pole__iir__filter__cc.html">gr::filter::single_pole_iir_filter_cc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">single pole IIR filter with complex input, complex outputThe input and output satisfy a difference equation of the form  
     \f{
     y[n] - (1-alpha) y[n-1] = alpha x[n]
     \f}
       <a href="classgr_1_1filter_1_1single__pole__iir__filter__cc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1single__pole__iir__filter__ff.html">gr::filter::single_pole_iir_filter_ff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">single pole IIR filter with float input, float outputThe input and output satisfy a difference equation of the form  
     \f{
     y[n] - (1-alpha) y[n-1] = alpha x[n]
     \f}
       <a href="classgr_1_1filter_1_1single__pole__iir__filter__ff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__dc__blocker__cc.html">gr_dc_blocker_cc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a computationally efficient controllable DC blocker  <a href="classgr__dc__blocker__cc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__dc__blocker__ff.html">gr_dc_blocker_ff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a computationally efficient controllable DC blocker  <a href="classgr__dc__blocker__ff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__pfb__arb__resampler__ccf.html">gr_pfb_arb_resampler_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and float taps.  <a href="classgr__pfb__arb__resampler__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__pfb__arb__resampler__fff.html">gr_pfb_arb_resampler_fff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank arbitrary resampler with float input, float output and float taps.  <a href="classgr__pfb__arb__resampler__fff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__pfb__channelizer__ccf.html">gr_pfb_channelizer_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank channelizer with gr_complex input, gr_complex output and float taps.  <a href="classgr__pfb__channelizer__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__pfb__clock__sync__ccf.html">gr_pfb_clock_sync_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Timing synchronizer using polyphase filterbanks.  <a href="classgr__pfb__clock__sync__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__pfb__clock__sync__fff.html">gr_pfb_clock_sync_fff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Timing synchronizer using polyphase filterbanks.  <a href="classgr__pfb__clock__sync__fff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__pfb__decimator__ccf.html">gr_pfb_decimator_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank bandpass decimator with gr_complex input, gr_complex output and float taps.  <a href="classgr__pfb__decimator__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__pfb__interpolator__ccf.html">gr_pfb_interpolator_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank interpolator with gr_complex input, gr_complex output and float taps.  <a href="classgr__pfb__interpolator__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr__pfb__synthesizer__ccf.html">gr_pfb_synthesizer_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase synthesis filterbank with gr_complex input, gr_complex output and float taps.  <a href="classgr__pfb__synthesizer__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdc__blocker__cc.html">dc_blocker_cc</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a computationally efficient controllable DC blocker  <a href="classdc__blocker__cc.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdc__blocker__ff.html">dc_blocker_ff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">a computationally efficient controllable DC blocker  <a href="classdc__blocker__ff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1pfb__arb__resampler__ccf.html">gr::filter::pfb_arb_resampler_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and float taps.  <a href="classgr_1_1filter_1_1pfb__arb__resampler__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1pfb__arb__resampler__fff.html">gr::filter::pfb_arb_resampler_fff</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank arbitrary resampler with float input, float output and float taps.  <a href="classgr_1_1filter_1_1pfb__arb__resampler__fff.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1pfb__channelizer__ccf.html">gr::filter::pfb_channelizer_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank channelizer with gr_complex input, gr_complex output and float taps.  <a href="classgr_1_1filter_1_1pfb__channelizer__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1pfb__decimator__ccf.html">gr::filter::pfb_decimator_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank bandpass decimator with gr_complex input, gr_complex output and float taps.  <a href="classgr_1_1filter_1_1pfb__decimator__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1pfb__synthesizer__ccf.html">gr::filter::pfb_synthesizer_ccf</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase synthesis filterbank with gr_complex input, gr_complex output and float taps.  <a href="classgr_1_1filter_1_1pfb__synthesizer__ccf.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1filter_1_1kernel_1_1polyphase__filterbank.html">gr::filter::kernel::polyphase_filterbank</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Polyphase filterbank parent class.  <a href="classgr_1_1filter_1_1kernel_1_1polyphase__filterbank.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static sptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filter__blk.html#gafeea11c42f64d4b2f9c850a520869c20">gr::filter::fft_filter_ccc::make</a> (int decimation, const std::vector&lt; <a class="el" href="gr__complex_8h.html#aec4bfe41433369afae9327f1b0bc9109">gr_complex</a> &gt; &amp;<a class="el" href="gr-filter_2include_2filter_2interpolator__taps_8h.html#a30bf032e13c2a9fc4a98e14e390cd65a">taps</a>, int nthreads=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast FFT filter with gr_complex input, gr_complex output and gr_complex tapsThis block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.  <a href="#gafeea11c42f64d4b2f9c850a520869c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static sptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filter__blk.html#gae1c9c502174fbfd286bc485e29d4d1fe">gr::filter::fft_filter_fff::make</a> (int decimation, const std::vector&lt; float &gt; &amp;<a class="el" href="gr-filter_2include_2filter_2interpolator__taps_8h.html#a30bf032e13c2a9fc4a98e14e390cd65a">taps</a>, int nthreads=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast FFT filter with float input, float output and float tapsThis block implements a real-value decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.  <a href="#gae1c9c502174fbfd286bc485e29d4d1fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static sptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filter__blk.html#gabb8baed7802373d3e08e6687afe15f14">gr::filter::filter_delay_fc::make</a> (const std::vector&lt; float &gt; &amp;<a class="el" href="gr-filter_2include_2filter_2interpolator__taps_8h.html#a30bf032e13c2a9fc4a98e14e390cd65a">taps</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter-Delay Combination Block.The block takes one or two float stream and outputs a complex stream.  <a href="#gabb8baed7802373d3e08e6687afe15f14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static sptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__filter__blk.html#ga2715c7adf640152f5fcec29db27541ab">gr::filter::hilbert_fc::make</a> (unsigned int ntaps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hilbert transformer.real output is input appropriately delayed. imaginary output is hilbert filtered (90 degree phase shift) version of input.  <a href="#ga2715c7adf640152f5fcec29db27541ab"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2715c7adf640152f5fcec29db27541ab"></a><!-- doxytag: member="gr::filter::hilbert_fc::make" ref="ga2715c7adf640152f5fcec29db27541ab" args="(unsigned int ntaps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static sptr <a class="el" href="group__filter__blk.html#ga2715c7adf640152f5fcec29db27541ab">gr::filter::hilbert_fc::make</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ntaps</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hilbert transformer.real output is input appropriately delayed. imaginary output is hilbert filtered (90 degree phase shift) version of input. </p>

</div>
</div>
<a class="anchor" id="gabb8baed7802373d3e08e6687afe15f14"></a><!-- doxytag: member="gr::filter::filter_delay_fc::make" ref="gabb8baed7802373d3e08e6687afe15f14" args="(const std::vector&lt; float &gt; &amp;taps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static sptr <a class="el" href="group__filter__blk.html#gabb8baed7802373d3e08e6687afe15f14">gr::filter::filter_delay_fc::make</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>taps</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Filter-Delay Combination Block.The block takes one or two float stream and outputs a complex stream. </p>
<p>If only one float stream is input, the real output is a delayed version of this input and the imaginary output is the filtered output.</p>
<p>If two floats are connected to the input, then the real output is the delayed version of the first input, and the imaginary output is the filtered output.</p>
<p>The delay in the real path accounts for the group delay introduced by the filter in the imaginary path. The filter taps needs to be calculated before initializing this block. </p>

</div>
</div>
<a class="anchor" id="gafeea11c42f64d4b2f9c850a520869c20"></a><!-- doxytag: member="gr::filter::fft_filter_ccc::make" ref="gafeea11c42f64d4b2f9c850a520869c20" args="(int decimation, const std::vector&lt; gr_complex &gt; &amp;taps, int nthreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static sptr <a class="el" href="group__filter__blk.html#gafeea11c42f64d4b2f9c850a520869c20">gr::filter::fft_filter_ccc::make</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decimation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="gr__complex_8h.html#aec4bfe41433369afae9327f1b0bc9109">gr_complex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>taps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast FFT filter with gr_complex input, gr_complex output and gr_complex tapsThis block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1. </p>
<p>The filter takes a set of complex (or real) taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the <a class="el" href="classgr_1_1filter_1_1firdes.html" title="Finite Impulse Response (FIR) filter design functions.">filter.firdes</a> and filter.optfir classes provide convenient generating methods.</p>
<p>This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">decimation</td><td>&gt;= 1 </td></tr>
    <tr><td class="paramname">taps</td><td>complex filter taps </td></tr>
    <tr><td class="paramname">nthreads</td><td>number of threads for the FFT to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1c9c502174fbfd286bc485e29d4d1fe"></a><!-- doxytag: member="gr::filter::fft_filter_fff::make" ref="gae1c9c502174fbfd286bc485e29d4d1fe" args="(int decimation, const std::vector&lt; float &gt; &amp;taps, int nthreads=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static sptr <a class="el" href="group__filter__blk.html#gae1c9c502174fbfd286bc485e29d4d1fe">gr::filter::fft_filter_fff::make</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decimation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>taps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast FFT filter with float input, float output and float tapsThis block implements a real-value decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1. </p>
<p>The filter takes a set of real-valued taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the <a class="el" href="classgr_1_1filter_1_1firdes.html" title="Finite Impulse Response (FIR) filter design functions.">filter.firdes</a> and filter.optfir classes provide convenient generating methods.</p>
<p>This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">decimation</td><td>&gt;= 1 </td></tr>
    <tr><td class="paramname">taps</td><td>float filter taps </td></tr>
    <tr><td class="paramname">nthreads</td><td>number of threads for the FFT to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Mon Oct 14 2013 11:58:12 for GNU Radio 3.6.4.2 C++ API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
