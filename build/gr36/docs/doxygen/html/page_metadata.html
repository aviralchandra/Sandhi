<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GNU Radio 3.6.4.2 C++ API: Metadata Information</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio 3.6.4.2 C++ API
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('page_metadata.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Metadata Information </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="Introduction"></a>
Introduction</h2>
<p>Metadata files have extra information in the form of headers that carry metadata about the samples in the file. Raw, binary files carry no extra information and must be handled delicately. Any changes in the system state such as sample rate or if a receiver's frequency are not conveyed with the data in the file itself. Header of metadata solve this problem.</p>
<p>We write metadata files using <a class="el" href="classgr_1_1blocks_1_1file__meta__sink.html" title="Write stream to file with meta-data headers.These files represent data as binary information in betwe...">gr::blocks::file_meta_sink</a> and read metadata files using <a class="el" href="classgr_1_1blocks_1_1file__meta__source.html" title="Reads stream from file with meta-data headers. Headers are parsed into tags.The information in the me...">gr::blocks::file_meta_source</a>.</p>
<p>Metadata files have headers that carry information about a segment of data within the file. The header structure is described in detail in the next section. A metadata file always starts with a header that describes the basic structure of the data. It contains information about the item size, data type, if it's complex, the sample rate of the segment, the time stamp of the first sample of the segment, and information regarding the header size and segment size.</p>
<p>Headers have two main tags associated with them:</p>
<ul>
<li>rx_rate: the sample rate of the stream.</li>
<li>rx_time: the time stamp of the first item in the segment.</li>
</ul>
<p>These tags were inspired by the UHD tag format.</p>
<p>The header gives enough information to process and handle the data. One cautionary note, though, is that the data type should never change within a file. There should be very little need for this, but more importantly. GNU Radio blocks can only set the data type of their IO signatures in the constructor, so changes in the data type afterward will not be recognized.</p>
<p>We also have an extra header segment that is option. This can be loaded up at the beginning by the user specifying some extra metadata that should be transmitted along with the data. It also grows whenever it sees a stream tag, so the dictionary will contain and key:value pairs out of tags from the flowgraph.</p>
<h3><a class="anchor" id="types"></a>
Types of Metadata Files</h3>
<p>GNU Radio currently supports two types of metadata files:</p>
<ul>
<li>inline: headers are inline with the data in the same file.</li>
<li>detached: headers are in a separate header file from the data.</li>
</ul>
<p>The inline method is the standard version. When a detached header is used, the headers are simply inserted back-to-back in the detached header file. The dat file, then, is the standard raw binary format with no interruptions in the data.</p>
<h3><a class="anchor" id="updating"></a>
Updating Headers</h3>
<p>While there is always a header that starts a metadata file, they are updated throughout as well. There are two events that trigger a new header. We define a segment as the unit of data associated with the last header.</p>
<p>The first event that will trigger a new header is when enough samples have been written for the given segment. This number is defined as the maximum segment size and is a parameter we pass to the file_meta_sink. It defaults to 1 million items (items, not bytes). When that number of items is reached, a new header is generated and a new segment is started. This makes it easier for us to manipulate the data later and helps protect against catastrophic data loss.</p>
<p>The second event to trigger a new segment is if a new tag is observed. If the tag is a standard tag in the header, the header value is updated, the header and current extras are written to file, and the segment begins again. If a tag from the extras is seen, the value associated with that tag is updated; and if a new tag is seen, a new key:value pair are added to the extras dictionary.</p>
<p>When new tags are seen, we generate a new segment so that we make sure that all samples in that segment are defined by the header. If the sample rate changes, we create a new segment where all of the new samples are at that new rate. Also, in the case of UHD devices, if a segment loss is observed, it will generate a new timestamp as a tag of 'rx_time'. We create a new file segment that reflects this change to keep the sample times exact.</p>
<h3><a class="anchor" id="implementation"></a>
Implementation</h3>
<p>Metadata files are created using <a class="el" href="classgr_1_1blocks_1_1file__meta__sink.html" title="Write stream to file with meta-data headers.These files represent data as binary information in betwe...">gr::blocks::file_meta_sink</a>. The default behavior is to create a single file with inline headers as metadata. An option can be set to switch to detached header mode.</p>
<p>Metadata file are read into a flowgraph using <a class="el" href="classgr_1_1blocks_1_1file__meta__source.html" title="Reads stream from file with meta-data headers. Headers are parsed into tags.The information in the me...">gr::blocks::file_meta_source</a>. This source reads a metadata file, inline by default with a settable option to use detached headers. The data from the segments is converted into a standard streaming output. The 'rx_rate' and 'rx_time' and all key:value pairs in the extra header are converted into tags and added to the stream tags interface.</p>
<h2><a class="anchor" id="structure"></a>
Structure</h2>
<p>The file metadata consists of a static mandatory header and a dynamic optional extras header. Each header is a separate PMT dictionary. Headers are created by building a PMT dictionary (<a class="el" href="namespacepmt.html#a1b693d7111cf0ed21c62d546f9f0a4c6" title="Make an empty dictionary.">pmt::pmt_make_dict</a>) of key:value pairs, then the dictionary is serialized into a string to be written to file. The header is always the same length that is predetermined by the version of the header (this must be known already). The header will then indicate if there is an extra data to be extracted as a separate serialized dictionary.</p>
<p>To work with the PMTs for creating and extracting header information, we use PMT operators. For example, we create a simplified version of the header in C++ like this:</p>
<div class="fragment"><pre class="fragment">  <span class="keyword">using namespace </span>pmt;
  <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="namespacegr_1_1blocks.html#aa3ab382f8014358ed9a5f35d8f79f885">METADATA_VERSION</a> = 0x0;
  <a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa" title="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt_t</a> header;
  header = <a class="code" href="namespacepmt.html#a1b693d7111cf0ed21c62d546f9f0a4c6" title="Make an empty dictionary.">pmt_make_dict</a>();
  header = <a class="code" href="namespacepmt.html#aebcc6302548a69c3d0653a8abdd42999" title="Return a new dictionary with key associated with value.">pmt_dict_add</a>(header, <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64" title="Make pmt symbol.">mp</a>(<span class="stringliteral">&quot;version&quot;</span>), <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64" title="Make pmt symbol.">mp</a>(<a class="code" href="namespacegr_1_1blocks.html#aa3ab382f8014358ed9a5f35d8f79f885">METADATA_VERSION</a>));
  header = <a class="code" href="namespacepmt.html#aebcc6302548a69c3d0653a8abdd42999" title="Return a new dictionary with key associated with value.">pmt_dict_add</a>(header, <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64" title="Make pmt symbol.">mp</a>(<span class="stringliteral">&quot;rx_rate&quot;</span>), <a class="code" href="namespacepmt.html#a90faad6086ac00280e0cfd8bb541bd64" title="Make pmt symbol.">mp</a>(samp_rate));
  std::string hdr_str = <a class="code" href="namespacepmt.html#a9ec30079614ead54081b29c3473181be" title="Provide a simple string generating interface to pmt&#39;s serialize function.">pmt_serialize_str</a>(header);
</pre></div><p>The call to <a class="el" href="namespacepmt.html#aebcc6302548a69c3d0653a8abdd42999" title="Return a new dictionary with key associated with value.">pmt::pmt_dict_add</a> adds a new key:value pair to the dictionary. Notice that it both takes and returns the 'header' variable. This is because we are actually creating a new dictionary with this function, so we just assign it to the same variable.</p>
<p>The 'mp' functions are convenience functions provided by the PMT library. They interpret the data type of the value being inserted and call the correct 'pmt_from_xxx' function. For more direct control over the data type, see PMT functions in <a class="el" href="pmt_8h.html">pmt.h</a>, such as <a class="el" href="namespacepmt.html#ad23c52d29b752f449c03213abb8ec263" title="Return the pmt value that represents the uint64 x.">pmt::pmt_from_uint64</a> or <a class="el" href="namespacepmt.html#aa4f8469d075bcccc81553ccb55408265" title="Return the pmt value that represents double x.">pmt::pmt_from_double</a>.</p>
<p>We finish this off by using <a class="el" href="namespacepmt.html#a9ec30079614ead54081b29c3473181be" title="Provide a simple string generating interface to pmt&#39;s serialize function.">pmt::pmt_serialize_str</a> to convert the PMT dictionary into a specialized string format that makes it easy to write to a file.</p>
<p>The header is always METADATA_HEADER_SIZE bytes long and a metadata file always starts with a header. So to extract the header from a file, we need to read in this many bytes from the beginning of the file and deserialize it. An important note about this is that the deserialize function must operate on a std::string. The serialized format of a dictionary contains null characters, so normal C character arrays (e.g., 'char *s') get confused.</p>
<p>Assuming that 'std::string str' contains the full string as read from a file, we can access the dictionary in C++ like this:</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa" title="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt_t</a> hdr = <a class="code" href="namespacepmt.html#a21ef652ea9953cc509d0f112a10a1cf0" title="Provide a simple string generating interface to pmt&#39;s deserialize function.">pmt_deserialize_str</a>(str);
  <span class="keywordflow">if</span>(<a class="code" href="namespacepmt.html#a12454dc2ceb8c1a167569dfd931677ab" title="Return true if key exists in dict.">pmt_dict_has_key</a>(hdr, <a class="code" href="namespacepmt.html#a9175b04fc88cb7be663ee7b7925dfda6" title="Return the symbol whose name is s.">pmt_string_to_symbol</a>(<span class="stringliteral">&quot;strt&quot;</span>))) {
    <a class="code" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa" title="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt_t</a> r = <a class="code" href="namespacepmt.html#addba630f2fea5c254e38661abfa8e728" title="If key exists in dict, return associated value; otherwise return not_found.">pmt_dict_ref</a>(hdr, <a class="code" href="namespacepmt.html#a9175b04fc88cb7be663ee7b7925dfda6" title="Return the symbol whose name is s.">pmt_string_to_symbol</a>(<span class="stringliteral">&quot;strt&quot;</span>), <a class="code" href="namespacepmt.html#abacba9cd6ea4261fee4bfb67e7133dad">PMT_NIL</a>);
    <a class="code" href="stdint_8h.html#aec6fcb673ff035718c238c8c9d544c47">uint64_t</a> seg_start = <a class="code" href="namespacepmt.html#af173bcf7561b2cb6863e835b510ee68f" title="Convert pmt to uint64 if possible.">pmt_to_uint64</a>(r);
    <a class="code" href="stdint_8h.html#aec6fcb673ff035718c238c8c9d544c47">uint64_t</a> extra_len = seg_start - <a class="code" href="namespacegr_1_1blocks.html#a9b8c10e9339bb3094d0b5fd2cf2d3f53">METADATA_HEADER_SIZE</a>;
  }
</pre></div><p>This example first deserializes the string into a PMT dictionary again. This will throw an error if the string is malformed and cannot be deserialized correctly. We then want to get access to the item with key 'strt'. As the next subsection will show, this value indicates at which byte the data segment starts. We first check to make sure that this key exists in the dictionary. If not, our header does not contain the correct information and we might want to handle this as an error.</p>
<p>Assuming the header is properly formatted, we then get the particular item referenced by the key 'strt'. This is a uint64_t, so we use the PMT function to extract and convert this value properly. We now know if we have an extra header in the file by looking at the difference between 'seg_start' and the static header size, METADATA_HEADER_SIZE. If the 'extra_len' is greater than 0, we know we have an extra header that we can process. Moreover, this also tells us the size of the serialized PMT dictionary in bytes, so we can easily read this many bytes from the file. We can then deserialize and parse this header just like the first.</p>
<h3><a class="anchor" id="header"></a>
Header Information</h3>
<p>The header is a PMT dictionary with a known structure. This structure may change, but we version the headers, so all headers of version X must be the same length and structure. As of now, we only have version 0 headers, which look like the following:</p>
<ul>
<li>version: (char) version number (usually set to METADATA_VERSION)</li>
<li>rx_rate: (double) Stream's sample rate</li>
<li>rx_time: (<a class="el" href="namespacepmt.html#ab4b70d9293452eb74dd07c670e6811fa" title="typedef for shared pointer (transparent reference counting). See http://www.boost.org/libs/smart_ptr/smart_ptr.htm">pmt::pmt_t</a> pair - (uint64_t, double)) Time stamp (format from UHD)</li>
<li>size: (int) item size in bytes - reflects vector length if any.</li>
<li>type: (int) data type (enum below)</li>
<li>cplx: (bool) true if data is complex</li>
<li>strt: (uint64_t) start of data relative to current header</li>
<li>bytes: (uint64_t) size of following data segment in bytes</li>
</ul>
<p>The data types are indicated by an integer value from the following enumeration type:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">enum</span> <a class="code" href="namespacegr_1_1blocks.html#aaf04a89b376fbc06cb75effeb40111b6">gr_file_types</a> {
  <a class="code" href="namespacegr_1_1blocks.html#aaf04a89b376fbc06cb75effeb40111b6a0ccdd1487ca349aea3efde7daecaef65">GR_FILE_BYTE</a>=0,
  <a class="code" href="namespacegr_1_1blocks.html#aaf04a89b376fbc06cb75effeb40111b6a9398c5264fb25d5aa2a9d08f1e68ad79">GR_FILE_CHAR</a>=0,
  <a class="code" href="namespacegr_1_1blocks.html#aaf04a89b376fbc06cb75effeb40111b6af08508c6dd7fc2dfb9529a9d82d6164f">GR_FILE_SHORT</a>=1,
  <a class="code" href="namespacegr_1_1blocks.html#aaf04a89b376fbc06cb75effeb40111b6ad98b7975f581d3864006ca663aee722d">GR_FILE_INT</a>,
  <a class="code" href="namespacegr_1_1blocks.html#aaf04a89b376fbc06cb75effeb40111b6a07ad82268bf96f539676f8545be40ec8">GR_FILE_LONG</a>,
  <a class="code" href="namespacegr_1_1blocks.html#aaf04a89b376fbc06cb75effeb40111b6aeba7eac37ba5a0ab76cf12efae97e39a">GR_FILE_LONG_LONG</a>,
  <a class="code" href="namespacegr_1_1blocks.html#aaf04a89b376fbc06cb75effeb40111b6acc39a9c09fab2b114ddb5ac6ec3a63f9">GR_FILE_FLOAT</a>,
  <a class="code" href="namespacegr_1_1blocks.html#aaf04a89b376fbc06cb75effeb40111b6a59bbff58dc3f23afa79642d7c9e09a14">GR_FILE_DOUBLE</a>,
};
</pre></div><h3><a class="anchor" id="extras"></a>
Extras Information</h3>
<p>The extras section is an optional segment of the header. If 'strt' == METADATA_HEADER_SIZE, then there is no extras. Otherwise, it is simply a PMT dictionary of key:value pairs. The extras header can contain anything and can grow while a program is running.</p>
<p>We can insert extra data into the header at the beginning if we wish. All we need to do is use the <a class="el" href="namespacepmt.html#aebcc6302548a69c3d0653a8abdd42999" title="Return a new dictionary with key associated with value.">pmt::pmt_dict_add</a> function to insert our hand-made metadata. This can be useful to add our own markers and information.</p>
<p>The main role of the extras header, though, is as a container to hold any stream tags. When a stream tag is observed coming in, the tag's key and value are added to the dictionary. Like a standard dictionary, any time a key already exists, the value will be updated. If the key does not exist, a new entry is created and the new key:value pair are added together. So any new tags that the file metadata sink sees will add to the dictionary. It is therefore important to always check the 'strt' value of the header to see if the length of the extras dictionary has changed at all.</p>
<p>When reading out data from the extras, we do not necessarily know the data type of the PMT value. The key is always a PMT symbol, but the value can be any other PMT type. There are PMT functions that allow us to query the PMT to test if it is a particular type. We also have the ability to do <a class="el" href="namespacepmt.html#aef241cfd8cabf5a7e363d7041ccbe1bb" title="Write pmt string representation to stdout.">pmt::pmt_print</a> on any PMT object to print it to screen. Before converting from a PMT to it's natural data type, it is necessary to know the data type.</p>
<h2><a class="anchor" id="Utilities"></a>
Utilities</h2>
<p>GNU Radio comes with a couple of utilities to help in debugging and manipulating metadata files. There is a general parser in Python that will convert the PMT header and extra header into Python dictionaries. This utility is:</p>
<ul>
<li>gr-blocks/python/parse_file_metadata.py</li>
</ul>
<p>This program is installed into the Python directory under the 'gnuradio' module, so it can be accessed with:</p>
<div class="fragment"><pre class="fragment">from gnuradio.blocks <span class="keyword">import</span> parse_file_metadata
</pre></div><p>It defines HEADER_LENGTH as the static length of the metadata header size. It also has dictionaries that can be used to convert from the file type to a string (ftype_to_string) and one to convert from the file type to the size of the data type in bytes (ftype_to_size).</p>
<p>The 'parse_header' takes in a PMT dictionary, parses it, and returns a Python dictionary. An optional 'VERBOSE' bool can be set to print the information to standard out.</p>
<p>The 'parse_extra_dict' is similar in that it converts from a PMT dictionary to a Python dictionary. The values are kept in their PMT format since we do not necessarily know the native data type.</p>
<p>A program called 'gr_read_file_metadata' is installed into the path and can be used to read out all header information from a metadata file. This program is just called with the file name as the first command-line argument. An option '-D' will handle detached header files where the file of headers is expected to be the file name of the data with '.hdr' appended to it.</p>
<h2><a class="anchor" id="Examples"></a>
Examples</h2>
<p>Examples are located in:</p>
<ul>
<li>gr-blocks/examples/metadata</li>
</ul>
<p>Currently, there are a few GRC example programs.</p>
<ul>
<li>file_metadata_sink: create a metadata file from UHD samples.</li>
<li>file_metadata_source: read the metadata file as input to a simple graph.</li>
<li>file_metadata_vector_sink: create a metadata file from UHD samples.</li>
<li>file_metadata_vector_source: read the metadata file as input to a simple graph.</li>
</ul>
<p>The file sink example can be switched to use a signal source instead of a UHD source, but no extra tagged data is used in this mode.</p>
<p>The file source example pushes the data stream to a new raw file while a tag debugger block prints out any tags observed in the metadata file. A QT GUI time sink is used to look at the signal as well.</p>
<p>The versions with 'vector' in the name are similar except they use vectors of data.</p>
<p>The following shows a simple way of creating extra metadata for a metadata file. This example is just showing how we can insert a date into the metadata to keep track of later. The date in this case is encoded as a vector of uint16 with [day, month, year].</p>
<div class="fragment"><pre class="fragment">  from gruel <span class="keyword">import</span> pmt
  from gnuradio <span class="keyword">import</span> blocks

  key = pmt.pmt_intern(<span class="stringliteral">&quot;date&quot;</span>)
  val = pmt.pmt_init_u16vector(3, [13,12,2012])

  extras = pmt.pmt_make_dict()
  extras = pmt.pmt_dict_add(extras, key, val)
  extras_str = pmt.pmt_serialize_str(extras)
  <span class="keyword">self</span>.sink = blocks.file_meta_sink(gr.sizeof_gr_complex,
                                    <span class="stringliteral">&quot;/tmp/metadat_file.out&quot;</span>,
                                    samp_rate, 1,
                                    blocks.GR_FILE_FLOAT, True,
                                    1000000, extra_str, False)
</pre></div> </div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Mon Oct 14 2013 11:58:11 for GNU Radio 3.6.4.2 C++ API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
