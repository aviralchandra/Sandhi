<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>GNU Radio 3.6.4.2 C++ API: Main Page</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">GNU Radio 3.6.4.2 C++ API
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('index.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">GNU Radio 3.6.4.2 C++ API Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="image">
<img src="gnuradio-logo.png" alt="gnuradio-logo.png"/>
</div>
<p>Welcome to GNU Radio!</p>
<p>For details about GNU Radio and using it, please see the <a href="http://gnuradio.org" target="_blank"><b>main project page</b></a>.</p>
<p>Other information about the project and discussion about GNU Radio, software radio, and communication theory in general can be found at the <a href="http://gnuradio.squarespace.com" target="_blank"><b>GNU Radio blog</b></a>.</p>
<h2><a class="anchor" id="build"></a>
Building GNU Radio</h2>
<p>See the <a class="el" href="build_guide.html">Build Instructions and Information</a> page for details about the project's dependencies and build process.</p>
<h2><a class="anchor" id="blocks"></a>
GNU Radio Blocks</h2>
<p>GNU Radio uses discrete signal processing blocks that are connected together to perform your signal processing application. This manual contain a list of all GNU Radio <a href="modules.html"><b>C++ Blocks</b></a>.</p>
<p>Please note that at this time, we haven't found an acceptable way to provide unified documentation for the C++ parts of the system and the parts written in Python (mostly hierarchical blocks). Until this gets worked out, please bear with us, or better yet, solve it for us!</p>
<h2><a class="anchor" id="toc"></a>
Manual Contents</h2>
<p>More details on packages in GNU Radio: </p>
<ul>
<li>page_audio </li>
<li><a class="el" href="page_digital.html">Digital Modulation</a> </li>
<li><a class="el" href="page_qtgui.html">QT Graphical User Interface</a> </li>
<li>page_uhd </li>
<li>page_vocoder</li>
</ul>
<p>More details on GNU Radio concepts: </p>
<ul>
<li><a class="el" href="page_pmt.html">Polymorphic Types</a> </li>
<li><a class="el" href="page_msg_passing.html">Message Passing</a> </li>
<li><a class="el" href="page_metadata.html">Metadata Information</a> </li>
<li><a class="el" href="volk_guide.html">Instructions for using Volk in GNU Radio</a> </li>
<li><a class="el" href="page_pfb.html">Polyphase Filterbanks</a></li>
</ul>
<h2><a class="anchor" id="flowgraph"></a>
Operating a Flowgraph</h2>
<p>The basic data structure in GNU Radio is the flowgraph, which represents the connections of the blocks through which a continuous stream of samples flows. The concept of a flowgraph is an acyclic directional graph with one or more source blocks (to insert samples into the flowgraph), one or more sink blocks (to terminate or export samples from the flowgraph), and any signal processing blocks in between.</p>
<p>A program must at least create a GNU Radio 'top_block', which represents the top-most structure of the flowgraph. The top blocks provide the overall control and hold methods such as 'start,' 'stop,' and 'wait.'</p>
<p>The general construction of a GNU Radio application is to create a <a class="el" href="structgr__top__block.html">gr_top_block</a>, instantiate the blocks, connect the blocks together, and then start the <a class="el" href="structgr__top__block.html">gr_top_block</a>. The following program shows how this is done. A single source and sink are used with a FIR filter between them.</p>
<div class="fragment"><pre class="fragment">    from gnuradio <span class="keyword">import</span> gr, filter
    
    <span class="keyword">class </span>my_topblock(gr.top_block):
        def __init__(self):
            gr.top_block.__init__(self)
    
            amp = 1
            <a class="code" href="gnuradio-core_2src_2lib_2filter_2interpolator__taps_8h.html#a30bf032e13c2a9fc4a98e14e390cd65a">taps</a> = filter.firdes.low_pass(1, 1, 0.1, 0.01)
            
            self.src = gr.noise_source_c(gr.GR_GAUSSIAN, amp)
            self.flt = filter.fir_filter_ccf(1, taps)
            self.snk = gr.null_sink(gr.sizeof_gr_complex)
    
            self.connect(self.src, self.flt, self.snk)
    
    if __name__ == &quot;__main__&quot;:
        tb = my_topblock()
        tb.start()
        tb.wait()
</pre></div><p>The 'tb.start()' starts the data flowing through the flowgraph while the 'tb.wait()' is the equivalent of a thread's 'join' operation and blocks until the <a class="el" href="structgr__top__block.html">gr_top_block</a> is done.</p>
<p>An alternative to using the 'start' and 'wait' methods, a 'run' method is also provided for convenience that is a blocking start call; equivalent to the above 'start' followed by a 'wait.'</p>
<h3><a class="anchor" id="latency"></a>
Latency and Throughput</h3>
<p>By default, GNU Radio runs a scheduler that attempts to optimize throughput. Using a dynamic scheduler, blocks in a flowgraph pass chunks of items from sources to sinks. The sizes of these chunks will vary depending on the speed of processing. For each block, the number of items is can process is dependent on how much space it has in its output buffer(s) and how many items are available on the input buffer(s).</p>
<p>The consequence of this is that often a block may be called with a very large number of items to process (several thousand). In terms of speed, this is efficient since now the majority of the processing time is taken up with processing samples. Smaller chunks mean more calls into the scheduler to retrieve more data. The downside to this is that it can lead to large latency while a block is processing a large chunk of data.</p>
<p>To combat this problem, the <a class="el" href="structgr__top__block.html">gr_top_block</a> can be passed a limit on the number of output items a block will ever receive. A block may get less than this number, but never more, and so it serves as an upper limit to the latency any block will exhibit. By limiting the number of items per call to a block, though, we increase the overhead of the scheduler, and so reduce the overall efficiency of the application.</p>
<p>To set the maximum number of output items, we pass a value into the 'start' or 'run' method of the <a class="el" href="structgr__top__block.html">gr_top_block</a>:</p>
<div class="fragment"><pre class="fragment">     tb.start(1000)
     tb.wait()
or
     tb.run(1000)
</pre></div><p>Using this method, we place a global restriction on the size of items to all blocks. Each block, though, has the ability to overwrite this with its own limit. Using the 'set_max_noutput_items(m)' method for an individual block will overwrite the global setting. For example, in the following code, the global setting is 1000 items max, except for the FIR filter, which can receive up to 2000 items.</p>
<div class="fragment"><pre class="fragment">     tb.flt.set_max_noutput_items(2000)
     tb.run(1000)
</pre></div><p>In some situations, you might actually want to restrict the size of the buffer itself. This can help to prevent a buffer who is blocked for data from just increasing the amount of items in its buffer, which will then cause an increased latency for new samples. You can set the size of an output buffer for each output port for every block.</p>
<p>WARNING: This is an advanced feature in GNU Radio and should not be used without a full understanding of this concept as explained below.</p>
<p>To set the output buffer size of a block, you simply call:</p>
<div class="fragment"><pre class="fragment">     tb.blk0.set_max_output_buffer(2000)
     tb.blk1.set_max_output_buffer(1, 2000)
     tb.start()
     print tb.blk1.max_output_buffer(0)
     print tb.blk1.max_output_buffer(1)
</pre></div><p>In the above example, all ports of blk0 are set to a buffer size of 2000 in _items_ (not bytes), and blk1 only sets the size for output port 1, any and all other ports use the default. The third and fourth lines just print out the buffer sizes for ports 0 and 1 of blk1. This is done after start() is called because the values are updated based on what is actually allocated to the block's buffers.</p>
<p>NOTES:</p>
<p>1. Buffer length assignment is done once at runtime (i.e., when run() or start() is called). So to set the max buffer lengths, the set_max_output_buffer calls must be done before this.</p>
<p>2. Once the flowgraph is started, the buffer lengths for a block are set and cannot be dynamically changed, even during a lock()/unlock(). If you need to change the buffer size, you will have to delete the block and rebuild it, and therefore must disconnect and reconnect the blocks.</p>
<p>3. This can affect throughput. Large buffers are designed to improve the efficiency and speed of the program at the expense of latency. Limiting the size of the buffer may decrease performance.</p>
<p>4. The real buffer size is actually based on a minimum granularity of the system. Typically, this is a page size, which is typically 4096 bytes. This means that any buffer size that is specified with this command will get rounded up to the nearest granularity (e.g., page) size. When calling max_output_buffer(port) after the flowgraph is started, you will get how many items were actually allocated in the buffer, which may be different than what was initially specified.</p>
<h2><a class="anchor" id="reconfigure"></a>
Reconfiguring Flowgraphs</h2>
<p>It is possible to reconfigure the flowgraph at runtime. The reconfiguration is meant for changes in the flowgraph structure, not individual parameter settings of the blocks. For example, changing the constant in a gr_add_const_cc block can be done while the flowgraph is running using the 'set_k(k)' method.</p>
<p>Reconfiguration is done by locking the flowgraph, which stops it from running and processing data, performing the reconfiguration, and then restarting the graph by unlocking it.</p>
<p>The following example code shows a graph that first adds two gr_noise_source_c blocks and then replaces the gr_add_cc block with a gr_sub_cc block to then subtract the sources.</p>
<div class="fragment"><pre class="fragment">from gnuradio <span class="keyword">import</span> gr
<span class="keyword">import</span> time

<span class="keyword">class </span>mytb(gr.top_block):
    def __init__(self):
        gr.top_block.__init__(self)

        self.src0 = gr.noise_source_c(gr.GR_GAUSSIAN, 1)
        self.src1 = gr.noise_source_c(gr.GR_GAUSSIAN, 1)
        self.add  = gr.add_cc()
        self.sub  = gr.sub_cc()
        self.head = gr.head(gr.sizeof_gr_complex, 1000000)
        self.snk  = gr.file_sink(gr.sizeof_gr_complex, &quot;output.32fc&quot;)

        self.connect(self.src0, (self.add,0))
        self.connect(self.src1, (self.add,1))
        self.connect(self.add, self.head)
        self.connect(self.head, self.snk)

def <a class="code" href="aadvark_8h.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>():
    tb = mytb()
    tb.start()
    time.sleep(0.01)

<span class="preprocessor">    # Stop flowgraph and disconnect the add block</span>
<span class="preprocessor"></span>    tb.lock()
    tb.disconnect(tb.add, tb.head)
    tb.disconnect(tb.src0, (tb.add,0))
    tb.disconnect(tb.src1, (tb.add,1))

<span class="preprocessor">    # Connect the sub block and restart</span>
<span class="preprocessor"></span>    tb.connect(tb.sub, tb.head)
    tb.connect(tb.src0, (tb.sub,0))
    tb.connect(tb.src1, (tb.sub,1))
    tb.unlock()

    tb.wait()

if __name__ == &quot;__main__&quot;:
    <a class="code" href="aadvark_8h.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()
</pre></div><p>During reconfiguration, the maximum noutput_items value can be changed either globally using the 'set_max_noutput_items(m)' on the <a class="el" href="structgr__top__block.html">gr_top_block</a> object or locally using the 'set_max_noutput_items(m)' on any given block object.</p>
<p>A block also has a 'unset_max_noutput_items()' method that unsets the local max noutput_items value so that block reverts back to using the global value.</p>
<p>The following example expands the previous example but sets and resets the max noutput_items both locally and globally.</p>
<div class="fragment"><pre class="fragment">from gnuradio <span class="keyword">import</span> gr
<span class="keyword">import</span> time

<span class="keyword">class </span>mytb(gr.top_block):
    def __init__(self):
        gr.top_block.__init__(self)

        self.src0 = gr.noise_source_c(gr.GR_GAUSSIAN, 1)
        self.src1 = gr.noise_source_c(gr.GR_GAUSSIAN, 1)
        self.add  = gr.add_cc()
        self.sub  = gr.sub_cc()
        self.head = gr.head(gr.sizeof_gr_complex, 1000000)
        self.snk  = gr.file_sink(gr.sizeof_gr_complex, &quot;output.32fc&quot;)

        self.connect(self.src0, (self.add,0))
        self.connect(self.src1, (self.add,1))
        self.connect(self.add, self.head)
        self.connect(self.head, self.snk)

def <a class="code" href="aadvark_8h.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>():
<span class="preprocessor">    # Start the gr_top_block after setting some max noutput_items.</span>
<span class="preprocessor"></span>    tb = mytb()
    tb.src1.set_max_noutput_items(2000)
    tb.start(100)
    time.sleep(0.01)
    
<span class="preprocessor">    # Stop flowgraph and disconnect the add block</span>
<span class="preprocessor"></span>    tb.lock()

    tb.disconnect(tb.add, tb.head)
    tb.disconnect(tb.src0, (tb.add,0))
    tb.disconnect(tb.src1, (tb.add,1))

<span class="preprocessor">    # Connect the sub block</span>
<span class="preprocessor"></span>    tb.connect(tb.sub, tb.head)
    tb.connect(tb.src0, (tb.sub,0))
    tb.connect(tb.src1, (tb.sub,1))

<span class="preprocessor">    # Set new max_noutput_items for the gr_top_block</span>
<span class="preprocessor"></span><span class="preprocessor">    # and unset the local value for src1</span>
<span class="preprocessor"></span>    tb.set_max_noutput_items(1000)
    tb.src1.unset_max_noutput_items()
    tb.unlock()

    tb.wait()

if __name__ == &quot;__main__&quot;:
    <a class="code" href="aadvark_8h.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>()
</pre></div><h2><a class="anchor" id="volk_main"></a>
Using Volk in GNU Radio</h2>
<p>The <a class="el" href="volk_guide.html">Instructions for using Volk in GNU Radio</a> page provides an overview of how to incorporate and use Volk in GNU Radio blocks.</p>
<p>Many blocks have already been converted to use Volk in their calls, so they can also serve as examples. See the <a class="el" href="gr__complex__to__xxx_8h.html">gr_complex_to_xxx.h</a> file for examples of various blocks that make use of Volk.</p>
<h2><a class="anchor" id="prefs"></a>
Configuration / Preference Files</h2>
<p>GNU Radio defines some of its basic behavior through a set of configuration files located in ${prefix}/etc/gnuradio/conf.d. Different components have different files listed in here for the various properties. These will be read once when starting a GNU Radio application, so updates during runtime will not affect them.</p>
<p>The configuration files use the following format:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"># Stuff from section 1</span>
<span class="preprocessor"></span>[section1]
var1 = value1 
var2 = value2 # value of 2

<span class="preprocessor"># Stuff from section 2</span>
<span class="preprocessor"></span>[section2]
var3 = value3
</pre></div><p>In this file, the hash mark ('#') indicates a comment and blank lines are ignored. Section labels are defined inside square brackets as a group distinguisher. All options must be associated with a section name. The options are listed one per line with the option name is given followed by an equals ('=') sign and then the value. All section and option names must not have white spaces (actually, all white spaces are ignored).</p>
<p>The value of an option can be a string or number and retrieved through a few different interfaces. There is a single preference object created when GNU Radio is launched. In Python, you can get this by making a new variable:</p>
<div class="fragment"><pre class="fragment">p = gr.prefs()
</pre></div><p>Similarly, in C++, we get a reference to the object by explicitly calling for the singleton of the object:</p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classgr__prefs.html" title="Base class for representing user preferences a la windows INI files.The real implementation is in Pyt...">gr_prefs</a> *p = <a class="code" href="classgr__prefs.html#a22198ff16aadb4b26020ff04233f03c3">gr_prefs::singleton</a>();
</pre></div><p>The methods associated with this preferences object are (from class <a class="el" href="classgr__prefs.html" title="Base class for representing user preferences a la windows INI files.The real implementation is in Pyt...">gr_prefs</a>):</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> has_section(<span class="keywordtype">string</span> section)
  <span class="keywordtype">bool</span> has_option(<span class="keywordtype">string</span> section, <span class="keywordtype">string</span> <a class="code" href="structoption.html">option</a>)
  <span class="keywordtype">string</span> get_string(<span class="keywordtype">string</span> section, <span class="keywordtype">string</span> <a class="code" href="structoption.html">option</a>, <span class="keywordtype">string</span> default_val)
  <span class="keywordtype">bool</span> get_bool(<span class="keywordtype">string</span> section, <span class="keywordtype">string</span> <a class="code" href="structoption.html">option</a>, <span class="keywordtype">bool</span> default_val)
  <span class="keywordtype">long</span> get_long(<span class="keywordtype">string</span> section, <span class="keywordtype">string</span> <a class="code" href="structoption.html">option</a>, <span class="keywordtype">long</span> default_val)
  <span class="keywordtype">double</span> get_double(<span class="keywordtype">string</span> section, <span class="keywordtype">string</span> <a class="code" href="structoption.html">option</a>, <span class="keywordtype">double</span> default_val)
</pre></div><p>When setting a Boolean value, we can use 0, 1, "True", "true", "False", "false", "On", "on", "Off", and "off".</p>
<p>All configuration preferences in these files can also be overloaded by an environmental variable. The environmental variable is named based on the section and option name from the configuration file as:</p>
<div class="fragment"><pre class="fragment">  GR_CONF_&lt;SECTION&gt;_&lt;OPTION&gt; = &lt;value&gt;
</pre></div><p>The "GR_CONF_" is a prefix to identify this as a GNU Radio configuration variable and the section and option names are in uppercase. The value is the same format that would be used in the config file itself. </p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Mon Oct 14 2013 11:58:43 for GNU Radio 3.6.4.2 C++ API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
